$date
	Fri Jun 17 18:53:57 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module computer_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module C0 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 # we $end
$var wire 32 $ wddm [31:0] $end
$var wire 32 % rdim [31:0] $end
$var wire 32 & rddm [31:0] $end
$var wire 32 ' aim [31:0] $end
$var wire 32 ( adm [31:0] $end
$scope module DM $end
$var wire 1 ! clk $end
$var wire 1 # we $end
$var wire 32 ) wd [31:0] $end
$var wire 32 * rd [31:0] $end
$var wire 32 + a [31:0] $end
$upscope $end
$scope module IM $end
$var wire 32 , rd [31:0] $end
$var wire 32 - a [31:0] $end
$upscope $end
$scope module P $end
$var wire 32 . addressData [31:0] $end
$var wire 32 / addressInstr [31:0] $end
$var wire 1 ! clk $end
$var wire 32 0 instr [31:0] $end
$var wire 32 1 readData [31:0] $end
$var wire 1 " rst $end
$var wire 32 2 writeData [31:0] $end
$var wire 1 3 zero $end
$var wire 5 4 writeReg [4:0] $end
$var wire 1 5 we3 $end
$var wire 1 # we $end
$var wire 32 6 srcB [31:0] $end
$var wire 32 7 srcA [31:0] $end
$var wire 32 8 signImm [31:0] $end
$var wire 32 9 result [31:0] $end
$var wire 1 : regDst $end
$var wire 32 ; rd2 [31:0] $end
$var wire 32 < pc_bar [31:0] $end
$var wire 32 = pc [31:0] $end
$var wire 1 > memToReg $end
$var wire 1 ? aluSrc $end
$var wire 32 @ aluResult [31:0] $end
$var wire 3 A aluControl [2:0] $end
$scope module Ctrl $end
$var wire 6 B funct [5:0] $end
$var wire 6 C opcode [5:0] $end
$var wire 3 D aluControl [2:0] $end
$var reg 2 E aluOp [1:0] $end
$var reg 1 ? aluSrc $end
$var reg 1 > memToReg $end
$var reg 1 : regDst $end
$var reg 1 # we $end
$var reg 1 5 we3 $end
$scope module ALUDecoder $end
$var wire 2 F aluOp [1:0] $end
$var wire 6 G funct [5:0] $end
$var reg 3 H aluControl [2:0] $end
$upscope $end
$upscope $end
$scope module MainALU $end
$var wire 3 I control [2:0] $end
$var wire 32 J b [31:0] $end
$var wire 32 K a [31:0] $end
$var reg 32 L result [31:0] $end
$var reg 1 3 zf $end
$upscope $end
$scope module PCPlusFour $end
$var wire 32 M b [31:0] $end
$var wire 32 N result [31:0] $end
$var wire 32 O a [31:0] $end
$upscope $end
$scope module PCReg $end
$var wire 1 ! clock $end
$var wire 32 P pc_bar [31:0] $end
$var wire 1 " reset $end
$var reg 32 Q pc [31:0] $end
$upscope $end
$scope module RegistersFile $end
$var wire 5 R a1 [4:0] $end
$var wire 5 S a2 [4:0] $end
$var wire 1 ! clk $end
$var wire 32 T rd1 [31:0] $end
$var wire 32 U rd2 [31:0] $end
$var wire 1 5 we3 $end
$var wire 32 V wd3 [31:0] $end
$var wire 5 W a3 [4:0] $end
$upscope $end
$scope module SignExtend $end
$var wire 16 X in [15:0] $end
$var wire 32 Y out [31:0] $end
$upscope $end
$scope module muxALU $end
$var wire 32 Z a [31:0] $end
$var wire 32 [ b [31:0] $end
$var wire 1 ? sel $end
$var wire 32 \ out [31:0] $end
$upscope $end
$scope module muxMemToReg $end
$var wire 32 ] a [31:0] $end
$var wire 32 ^ b [31:0] $end
$var wire 1 > sel $end
$var wire 32 _ out [31:0] $end
$upscope $end
$scope module muxWriteReg $end
$var wire 5 ` a [4:0] $end
$var wire 5 a b [4:0] $end
$var wire 1 : sel $end
$var wire 5 b out [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10001 b
b0 a
b10001 `
b10001001100110101010101110111 _
b10001001100110101010101110111 ^
b1000 ]
b1000 \
b1000 [
b1100 Z
b1000 Y
b1000 X
b10001 W
b10001001100110101010101110111 V
b1100 U
b0 T
b10001 S
b0 R
b0 Q
b100 P
b0 O
b100 N
b100 M
b1000 L
b0 K
b1000 J
b10 I
b10 H
b1000 G
b0 F
b0 E
b10 D
b101011 C
b1000 B
b10 A
b1000 @
1?
1>
b0 =
b100 <
b1100 ;
0:
b10001001100110101010101110111 9
b1000 8
b0 7
b1000 6
05
b10001 4
03
b1100 2
b10001001100110101010101110111 1
b10101100000100010000000000001000 0
b0 /
b1000 .
b0 -
b10101100000100010000000000001000 ,
b1000 +
b10001001100110101010101110111 *
b1100 )
b1000 (
b0 '
b10001001100110101010101110111 &
b10101100000100010000000000001000 %
b1100 $
1#
0"
0!
$end
#5
0#
15
b100011 C
b1000 <
b1000 N
b1000 P
b10001100000100010000000000001000 %
b10001100000100010000000000001000 ,
b10001100000100010000000000001000 0
b100 '
b100 -
b100 /
b100 =
b100 O
b100 Q
b1100 9
b1100 V
b1100 _
b1100 &
b1100 *
b1100 1
b1100 ^
1!
#10
0!
#15
b10011 9
b10011 V
b10011 _
0>
1:
0?
b10 E
b10 F
bx &
bx *
bx 1
bx ^
b10011 (
b10011 +
b10011 .
b10011 @
b10011 L
b10011 ]
b111 6
b111 J
b111 \
b10000 4
b10000 W
b10000 b
b100000 B
b100000 G
b11111111111111111000000000100000 8
b11111111111111111000000000100000 Y
b11111111111111111000000000100000 [
b1000000000100000 X
b10000 a
b111 $
b111 )
b111 2
b111 ;
b111 U
b111 Z
b10010 S
b10010 `
b0 C
b1100 7
b1100 K
b1100 T
b10001 R
b1100 <
b1100 N
b1100 P
b10001100101000000000100000 %
b10001100101000000000100000 ,
b10001100101000000000100000 0
b1000 '
b1000 -
b1000 /
b1000 =
b1000 O
b1000 Q
1!
#20
0!
#25
b11010 9
b11010 V
b11010 _
b11010 (
b11010 +
b11010 .
b11010 @
b11010 L
b11010 ]
b10100 4
b10100 W
b10100 b
b11111111111111111010000000100000 8
b11111111111111111010000000100000 Y
b11111111111111111010000000100000 [
b1010000000100000 X
b10100 a
b10011 7
b10011 K
b10011 T
b10000 R
b10000 <
b10000 N
b10000 P
b10000100101010000000100000 %
b10000100101010000000100000 ,
b10000100101010000000100000 0
b1100 '
b1100 -
b1100 /
b1100 =
b1100 O
b1100 Q
1!
#30
0!
#35
b11 A
b11 D
b11 H
x3
bx 9
bx V
bx _
05
b11 E
b11 F
bx (
bx +
bx .
bx @
bx L
bx ]
bx 4
bx W
bx b
bx 6
bx J
bx \
bx B
bx G
bx 8
bx Y
bx [
bx X
bx a
bx $
bx )
bx 2
bx ;
bx U
bx Z
bx S
bx `
bx C
bx 7
bx K
bx T
bx R
b10100 <
b10100 N
b10100 P
bx %
bx ,
bx 0
b10000 '
b10000 -
b10000 /
b10000 =
b10000 O
b10000 Q
1!
#40
0!
#45
b11000 <
b11000 N
b11000 P
b10100 '
b10100 -
b10100 /
b10100 =
b10100 O
b10100 Q
1!
#50
0!
